### Moving Least Squares Material Point Method (MLS-MPM)



Moving Least Squares Material Point Method (MLS-MPM) 是一种改进的材料点法（MPM），旨在提高数值模拟的准确性和稳定性。MLS-MPM结合了经典MPM和流体粒子模拟中的一些技术，通过使用移动最小二乘（Moving Least Squares, MLS）方法来进行粒子到网格的传输。

#### MLS-MPM的核心步骤

1. **初始化**
   - 初始化粒子的位置、速度、质量等属性。
   - 初始化网格，通常是一个固定的欧拉网格。

2. **粒子到网格的传输**
   - 使用移动最小二乘法计算粒子属性到网格点的贡献。MLS方法可以通过更高阶的插值来提高精度，减少数值耗散。

3. **网格上的计算**
   - 在网格上进行物理方程的求解，比如应力更新、速度更新等。
   - 使用显式或隐式时间积分方法来更新网格上的物理量。

4. **网格到粒子的回传**
   - 将更新后的网格属性回传到粒子。MLS方法再次用于插值，保证传输的准确性。

5. **粒子位置更新**
   - 根据更新后的速度和其他物理量更新粒子的位置。

#### 优点

- **减少数值耗散**
  MLS方法可以更准确地进行粒子到网格的传输，减少了数值耗散，特别是在处理复杂变形和高频振荡时表现优异。

- **高精度**
  高阶插值方法提高了模拟的精度，使得MLS-MPM在处理细节丰富的物理现象时更具优势。

- **更稳定**
  由于减少了数值误差，MLS-MPM在长时间模拟中表现更为稳定。



事实上，我们为了方便计算，将粒子系统视为整体，在不违反物理守恒（质量守恒定律和动量守恒定律）的情况下创建了网格。网格提供了相关物理量的统一计算框架，能够在计算过程中保持较高的数值稳定性。



#### Moving Least Squares 移动最小二乘

在MLS-MPM中，“粒子信息传输到网格”这一步骤的关键是使用移动最小二乘法（Moving Least Squares, MLS）将粒子的属性（如质量、动量等）传输到网格点。

假设我们有一个粒子，其位置为 $(x_p, y_p)$，速度为 $(v_x, v_y)$，质量为 $m$，以及其他属性。粒子位于一个二维网格内，网格点的间距为 $\Delta x = \Delta y$。

#### 传输步骤概述
1. **确定粒子周围的网格点**：找到粒子所在位置及其周围的网格点。
2. **计算权重**：根据粒子到每个网格点的距离，计算权重。
3. **属性传输**：将粒子的属性按权重分配给网格点。

#### 详细步骤
##### 1. 确定粒子周围的网格点
首先，确定粒子位于哪个网格单元内。假设网格点的索引从 $(0, 0)$ 开始，粒子所在网格单元的左下角索引可以通过对粒子坐标进行取整来获得：

$
i = \lfloor \frac{x_p}{\Delta x} \rfloor
$
$
j = \lfloor \frac{y_p}{\Delta y} \rfloor
$

然后，考虑粒子周围的网格点。通常我们会选择3x3的网格点邻域来进行权重计算，即：

$
(i-1, j-1), (i, j-1), (i+1, j-1)
$
$
(i-1, j), (i, j), (i+1, j)
$
$
(i-1, j+1), (i, j+1), (i+1, j+1)
$

##### 2. 计算权重
使用移动最小二乘法，权重通常根据粒子到每个网格点的距离来计算。以二次插值为例，权重计算如下：

首先，计算粒子在网格单元内的局部坐标：

$
x_l = \frac{x_p}{\Delta x} - i
$
$
y_l = \frac{y_p}{\Delta y} - j
$

然后，计算每个方向上的权重函数 $w(x)$ 和 $w(y)$。这里我们使用二次B样条权重函数：

$
w(x) = \begin{cases} 
0.5 \left(1.5 - x \right)^2 & 0 \leq x < 1.5 \\
0.75 - (x - 1)^2 & 0.5 \leq x < 1.5 \\
0.5 \left(x - 0.5 \right)^2 & 1 \leq x < 2.5
\end{cases}
$

对于每个网格点$(i+k, j+l)$，计算权重：

$
w_{i+k,j+l} = w(x_l - k) \cdot w(y_l - l)
$

##### 3. 属性传输
将粒子的属性（质量、动量等）按权重分配给网格点。以动量为例，粒子的动量为 $ \mathbf{p} = m \cdot \mathbf{v} $。对每个网格点，我们有：

$
\mathbf{p}_{i+k,j+l} += w_{i+k,j+l} \cdot \mathbf{p}
$

$
m_{i+k,j+l} += w_{i+k,j+l} \cdot m
$

##### 示例
假设粒子位于 $(1.3, 2.7)$ 的位置，其所在的网格单元索引为 $ (1, 2) $。局部坐标为 $(0.3, 0.7)$。我们需要计算周围9个网格点的权重并传输属性。

例如，粒子对左下角网格点 $(0, 1)$ 的权重：

$
w_{0,1} = w(0.3 - 1) \cdot w(0.7 - 1)
$

将动量和质量分配给这个网格点：

$
\mathbf{p}_{0,1} += w_{0,1} \cdot \mathbf{p}
$
$
m_{0,1} += w_{0,1} \cdot m
$

重复这个过程，计算并更新其他8个网格点的属性。



#### 网格上的计算：

施加外力，如重力

##### 边界处理：

1. 对于左右边界和上边界：被判定处于网格边界上的网格点将不具有速度、质量（velocity_x=velocity_y=0, mass=0）
2. 对于下边界：被判定处于下边界的网格点不被允许拥有 y 方向的负速度



#### 网格信息回传：

这一步骤仍然使用 MLS-MPM, 每个粒子的属性将从周围网格点的信息中得到更新



#### 其他参数：

在MLS-MPM（Moving Least Squares Material Point Method）中，以下参数在模拟过程中起着关键作用：

1. **Deformation Gradient \( F \)**
2. **Affine Momentum Matrix \( C \)**
3. **Determinant of the Deformation Gradient \( Jp \)**

这些参数在各个步骤中的作用和更新过程如下：

#### 1. Deformation Gradient \( F \)

##### 作用
- **定义**：变形梯度 \( F \) 是一个矩阵，描述了材料点的变形状态，即从参考配置到当前配置的变形映射。
- **物理意义**：它反映了粒子的形变，包括拉伸、压缩和剪切等。
- **在计算中**：用于计算应力和体积变化等。

##### 更新过程

- **P2G（粒子到网格传输）**：
  - \( F \) 在P2G过程中不变，只是其相关的物理量（如应力）会影响到网格点。

- **G2P（网格到粒子回传）**：
  - \( F \) 在这一步更新，通常使用时间步长 \( dt \) 和APIC矩阵 \( C \)。
  ```cpp
  auto F_new = (Mat(1) + dt * p.C) * p.F;
  p.F = F_new;
  ```
  - 这一步骤确保粒子的形变状态能够准确反映网格点的物理变化。

#### 2. Affine Momentum Matrix \( C \)

##### 作用
- **定义**：APIC 方法中的仿射动量矩阵 \( C \) 用于捕捉粒子的亚格尺度动量变化。
- **物理意义**：它能够更精确地描述粒子运动的速度梯度，从而改善模拟的稳定性和精度。

##### 更新过程

- **P2G（粒子到网格传输）**：
  - \( C \) 用于将粒子的动量和应力传输到网格点。
  ```cpp
  auto affine = stress + particle_mass * p.C;
  ```

- **G2P（网格到粒子回传）**：
  - \( C \) 在这一步根据网格点的速度更新，用于下一次P2G传输。
  ```cpp
  p.C = Mat(0);
  for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++) {
          auto dpos = (Vec(i, j) - fx);
          auto grid_v = Vec(grid[base_coord.x + i][base_coord.y + j]);
          auto weight = w[i].x * w[j].y;
          p.C += 4 * inv_dx * Mat::outer_product(weight * grid_v, dpos);
      }
  }
  ```

#### 3. Determinant of the Deformation Gradient \( Jp \)

##### 作用
- **定义**：变形梯度的行列式 \( Jp \) 代表了体积变化比率。
- **物理意义**：反映了粒子的体积变化，重要用于处理不可压缩性条件和材料体积守恒。

##### 更新过程

- **P2G（粒子到网格传输）**：
  - \( Jp \) 用于计算当前材料的属性，如拉梅参数的硬化修正。
  ```cpp
  auto e = std::exp(hardening * (1.0f - p.Jp));
  auto mu = mu_0 * e;
  auto lambda = lambda_0 * e;
  ```

- **G2P（网格到粒子回传）**：
  - \( Jp \) 根据更新后的变形梯度 \( F \) 计算更新。
  ```cpp
  real oldJ = determinant(p.F);
  F = svd_u * sig * transposed(svd_v);
  real Jp_new = clamp(p.Jp * oldJ / determinant(F), 0.6f, 20.0f);
  p.Jp = Jp_new;
  ```

#### 详细步骤中的更新

##### 初始化
初始化粒子时，通常将 \( F \) 设置为单位矩阵（表示没有变形）， \( C \) 设置为零矩阵（没有初始动量变化）， \( Jp \) 设置为1（初始体积保持不变）。

```cpp
Particle(Vec x, int c, Vec v=Vec(0)) :
    x(x),
    v(v),
    F(1),    // 单位矩阵
    C(0),    // 零矩阵
    Jp(1),   // 初始体积
    c(c) {}
```

##### 粒子到网格传输（P2G）

1. **计算变形梯度**：通过极分解。
2. **计算应力和动量贡献**：计算应力和动量的仿射矩阵，传输到网格点。

```cpp
auto PF = (2 * mu * (p.F-r) * transposed(p.F) + lambda * (J-1) * J);
auto stress = - (dt * vol) * (Dinv * PF);
auto affine = stress + particle_mass * p.C;
```

##### 网格上的计算

1. **更新速度**：在网格点上计算新速度，并应用外力（如重力）。
2. **边界条件处理**：在网格边界处理粒子的反弹和粘性边界。

```cpp
if (g[2] > 0) {
    g /= g[2];
    g += dt * Vector3(0, -200, 0);
    // 处理边界
    ...
}
```

#### 网格到粒子回传（G2P）

1. **计算权重**：根据粒子与网格点的相对位置计算权重。
2. **更新速度**：根据网格点的速度和权重更新粒子的速度。
3. **更新变形梯度**：计算新的变形梯度 \( F \) 并处理塑性变形。

```cpp
p.v += weight * grid_v;
auto F_new = (Mat(1) + dt * p.C) * p.F;
...
p.F = F_new;
```

